

```{r}

library(tidyverse)
library(reticulate)
library(tidymodels)

use_condaenv('r-reticulate')


```


```{r}

dat <- readRDS('../../data/soundout_data.rds') %>% 
  filter(trial_type == "midi_to_midi") %>% 
  select(stimuli, stimuli_durations, user_response_note, durations, similarity_rating)  %>% 
  rowwise() %>% 
  mutate(melody_1_prompt = glue::glue("notes: { {stimuli} }, durations: {stimuli_durations} "),
         melody_2_prompt = glue::glue("notes: {user_response_note}, durations: {durations} "),
         prompt = paste0("{ melody1 : { ", melody_1_prompt, "},  melody2 : { ", melody_2_prompt, "} }")
         ) %>% 
  ungroup() %>% 
  select(prompt, similarity_rating) %>% 
  rename(completion = similarity_rating) %>% 
  mutate(completion = as.character(completion))


```


```{r}

data_split <- initial_split(dat, prop = 3/4)

# Create dataframes for the two sets:
train_data <- training(data_split) %>% 
  reticulate::r_to_py()

val_data  <- testing(data_split) %>% 
  reticulate::r_to_py()

```


```{r}

train_data$to_json("similarity_train.jsonl", orient = 'records', lines= TRUE)

```

```{r}

val_data$to_json("similarity_val.jsonl", orient = 'records', lines= TRUE)

```

(Upload through online GUI)



```{r}


get_fine_tuned_completion <- function(prompt) {

  model <- "ft:davinci-002:personal::8tFCG3SU"

  # Set up the API endpoint
  endpoint <- "https://api.openai.com/v1/completions"

  # Prepare the request body
  data <- list(
    prompt = prompt,
    model = model,
    max_tokens = 1L,
    temperature = 0
  )

  # Make the API request
  response <- httr::POST(
    url = endpoint,
    httr::add_headers("Content-Type" = "application/json", "Authorization" = paste("Bearer", Sys.getenv("OPENAI_API_KEY"))),
    body = data,
    encode = "json"
  )

  # Check for a successful response
  if (httr::http_status(response)$category == "Success") {
    
    result <- httr::content(response, "parsed")

    prediction <- result$choices[[1]]$text
    
    return(prediction)

  } else {
    logging::logerror("API request failed. Status code: ", httr::http_status(response)$status_code)
  }

}


```


```{r}

val_data <- 
  val_data %>% 
    reticulate::py_to_r() %>% 
    rowwise() %>% 
    mutate(chatgpt_pred = get_fine_tuned_completion( prompt ) ) %>% 
    ungroup()

save(val_data, file = 'output/chatgpt_val_data.rda')

```


```{r}

# Technically this isn't a test set, actually... so need to figure something out here

# Note that "completion" is what was sim_ratings
chatgpt_lm <- lm(completion ~ as.numeric(chatgpt_pred), data = val_data)

```


```{r}

summary(chatgpt_lm)

```


It's not that great, anyway.




Word embedding approach


```{r}

get_chatgpt_word_embedding <- function(input) {


  data <- httr::POST(url = "https://api.openai.com/v1/embeddings", 
                    httr::add_headers(
                      Authorization = paste0("Bearer ", Sys.getenv("OPENAI_API_KEY"))
                      ),
                      httr::content_type_json(),
                    encode = "json",
                    body = list(
                      input = input,
                      model = "text-embedding-3-large"
                    ))
  
  rjson::fromJSON(httr::content(data, type="text"))$data[[1]]$embedding

}

```

```{r}

dat_we <- readRDS('../../data/soundout_data.rds') %>% 
  filter(trial_type == "midi_to_midi") %>% 
  select(stimuli, stimuli_durations, user_response_note, durations, similarity_rating) %>%
  mutate(trial_id = row_number()) %>% 
  pivot_longer(stimuli:durations, names_to = "melody_feature") %>% 
  mutate(melody_feature = 
           case_when(melody_feature == "stimuli" | melody_feature == "user_response_note" ~ "pitches",
                     melody_feature == "stimuli_durations" | melody_feature == "durations" ~ "rhythms")) %>%
  mutate(melody_no = rep(c(1, 1, 2, 2), times = max(trial_id))) %>% 
  pivot_wider(names_from = "melody_feature", values_from = "value") %>% 
  rowwise() %>% 
  mutate(melody = glue::glue("notes: { {pitches} }, durations: {rhythms}"),
         melody = paste0("{ ", melody, " }")) %>% 
  ungroup() %>% 
  rowwise() %>% 
  mutate(embedding = list( get_chatgpt_word_embedding(melody) )) %>% 
  ungroup() %>% 
  select(trial_id, melody_no, embedding, similarity_rating) %>% 
  pivot_wider(everything(), names_from = "melody_no", values_from = "embedding") %>% 
  rename(melody_1 = `1`,
         melody_2 = `2`) %>%  
  rowwise() %>% 
  mutate(cosine_sim = lsa::cosine( unlist(melody_1), unlist(melody_2) )) %>% 
  ungroup()


save(dat_we, file = 'output/dat_we.rda')

```

There isn't really a sense in there being a test set here because the model is already built.


```{r}

chatgpt_word_embedding_lm <- lm(similarity_rating ~ cosine_sim, data = dat_we)


```


```{r}

summary(chatgpt_word_embedding_lm)

```


Also not that impressive.




